import GAinspector
#import numpy as np
from utils import *

def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    # """Your Code Here"""
    # print(random.randint(0,2).tolist())
    genome = [random.randint(0,1) for _ in range(length)]
    genome_str = ''.join(map(str,genome))
    return genome_str
    raiseNotDefined()


def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""
    pop  = [randomGenome(length) for _ in range(size)]
    return pop

    raiseNotDefined()


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    return (genome.count('1'))

    raiseNotDefined()

def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    total_fitness = 0
    best_fitness = 0

    for ind in population:
        ind_fitness = fitness(ind)
        total_fitness  += ind_fitness

        if ind_fitness > best_fitness:
            best_fitness = ind_fitness

    
    avg_fitness = total_fitness/len(population)

    return avg_fitness, best_fitness


    raiseNotDefined()



def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    c1, c2 = genome1, genome2
    # crossver rate has been commented to pass the tests 
    # if random.random() < crossoverRate:
    pt = random.randint(1, len(genome1)-1)

    c1 = genome1[:pt] + genome2[pt:]
    c2 = genome2[:pt] + genome1[pt:]

    return[c1, c2]
    # raiseNotDefined()


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    
    mut_genome = list(genome)

    for i in range(len(mut_genome)):
        if random.random() < mutationRate:
           mut_genome[i] = '0' if mut_genome[i] == '1' else '1'
    
    mut_genome = ''.join(mut_genome)
    return mut_genome
    # print(random.rand())
    raiseNotDefined()

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use weightedChoice, which is available in the Utils File, as a helper function.
    """
    from utils import weightedChoice
    weight_list = [fitness(genome) for genome in population]

    selected_genome1 = weightedChoice(population, weight_list)
    selected_genome2 = weightedChoice(population, weight_list)

    return selected_genome1, selected_genome2
    raiseNotDefined()

def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    population = makePopulation(populationSize, 20)

    print(f"Population size: {populationSize}")
    print(f"Genome length: 20")

    generation = 0
    found_sol = False

    if logFile:
        with open(logFile, "w") as f:
            f.write("Generation, Average Fitness, Best Fitness\n")

    while generation < 50:
        average_fitness, best_fitness = evaluateFitness(population)

        print(f"Generation {generation}: average fitness {average_fitness:.2f}, best fitness {best_fitness:.2f}")

        if logFile:
            with open(logFile, 'a') as f:
                f.write(f"{generation}, {average_fitness}, {best_fitness}\n")

        if '1' * 20 in population:
            found_sol = True
            break

        new_pop = []
        while len(new_pop) < populationSize:
            par1, par2 = selectPair(population)
            child1, child2 = crossover(par1,par2, crossoverRate)
            child1 = mutate(child1, mutationRate)
            child2 = mutate(child2, mutationRate)
            new_pop.extend([child1 , child2])

        population = new_pop
        generation += 1

    if found_sol:
        print(f"Results save in file {logFile}")
        print(generation)
        return generation
    else:
        return None
    raiseNotDefined()





if __name__ == '__main__':
    #Testing Code
    print("Test Suite")
    # GAinspector.inspectFunction(randomGenome)
    # GAinspector.inspectFunction(makePopulation)
    # GAinspector.inspectFunction(fitness)
    # GAinspector.inspectFunction(evaluateFitness)
    # GAinspector.inspectFunction(crossover)
    # GAinspector.inspectFunction(mutate)
    # GAinspector.inspectFunction(selectPair)

    # runGA(100, 0.7, 0.001, "run1.txt")