import robby
#import numpy as np
from utils import *
import random
POSSIBLE_ACTIONS = ["MoveNorth", "MoveSouth", "MoveEast", "MoveWest", "StayPut", "PickUpCan", "MoveRandom"]
rw = robby.World(10, 10)
rw.graphicsOff()

def sortByFitness(genomes):
    tuples = [(fitness(g), g) for g in genomes]
    tuples.sort()
    sortedFitnessValues = [f for (f, g) in tuples]
    sortedGenomes = [g for (f, g) in tuples]
    return sortedGenomes, sortedFitnessValues


def randomGenome(length):
    """
    :param length:
    :return: string, random integers between 0 and 6 inclusive
    """

    """Your Code Here"""
    genome = [random.randint(0,6) for _ in range(length)]
    genome_str = ''.join(map(str,genome))
    return genome_str
    raiseNotDefined()



def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""

    pop  = [randomGenome(length) for _ in range(size)]
    return pop
    raiseNotDefined()

def fitness(genome, steps=200, init=0.50):
    """

    :param genome: to test
    :param steps: number of steps in the cleaning session
    :param init: amount of cans
    :return:
    """
    rw.graphicsOff(message="Graphics Disabled")
    if type(genome) is not str or len(genome) != 243:
        raise Exception("strategy is not a string of length 243")
    for char in genome:
        if char not in "0123456":
            raise Exception("strategy contains a bad character: '%s'" % char)
    if type(steps) is not int or steps < 1:
        raise Exception("steps must be an integer > 0")
    if type(init) is str:
        # init is a config file
        rw.load(init)
    elif type(init) in [int, float] and 0 <= init <= 1:
        # init is a can density
        rw.goto(0, 0)
        rw.distributeCans(init)
    else:
        raise Exception("invalid initial configuration")
    

    # simulate a cleaning session
    total_reward = 0
    for _ in range(25):
        # rw.reset()  # Reset the environment for each session
        rw.goto(0,0)
        rw.distributeCans(init)
        for _ in range(steps):
            percept_code = rw.getPerceptCode()
            action = int(genome[percept_code])
            reward = rw.performAction(POSSIBLE_ACTIONS[action])
            total_reward += reward
    average_reward = total_reward / 25
    return average_reward

    # raiseNotDefined()

def evaluateFitness(population):
    """
    :param population:
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual
    in the population.
    """

    total_fitness = 0
    best_fitness = 0

    for ind in population:
        ind_fitness = fitness(ind)
        total_fitness  += ind_fitness

        if ind_fitness > best_fitness:
            best_fitness = ind_fitness

    
    avg_fitness = total_fitness/len(population)

    return avg_fitness, best_fitness

    raiseNotDefined()


def crossover(genome1, genome2, crossoverRate):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    c1, c2 = genome1, genome2

    if random.random() < crossoverRate:

        pt = random.randint(1, len(genome1)-1)

        c1 = genome1[:pt] + genome2[pt:]
        c2 = genome2[:pt] + genome1[pt:]

    return [c1,c2]
    raiseNotDefined()


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    mut_genome = list(genome)

    for i in range(len(mut_genome)):
        if random.random() < mutationRate:
           mut_genome[i] = str(random.randint(0,6))
    
    mut_genome = ''.join(mut_genome)
    return mut_genome
    raiseNotDefined()

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use RankSelection,
    """
    from utils import weightedChoice

    sorted_pop, _ = sortByFitness(population)
    # print(len(sorted_pop))
    rank1 = weightedChoice(sorted_pop, weights=[i for i in range(1,len(sorted_pop) + 1)])
    rank2 = weightedChoice(sorted_pop, weights=[i for i in range(1,len(sorted_pop) + 1)])
  
    return rank1, rank2

    raiseNotDefined()


def runGA(populationSize, crossoverRate, mutationRate, logFile="GAoutput.txt"):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    population = makePopulation(populationSize,243)
    generations = 300
    best_fitness = float("-inf")
    best_strategy = None 


    with open(logFile, 'w') as output_file:
        for generation in range(generations + 1):
            # Evaluate fitness
            population, fitness_values = sortByFitness(population)

            #Best Strategy
            if fitness_values[-1] > best_fitness:
                best_fitness = fitness_values[-1]
                best_strategy = population[-1]

            # Generation data due to the log file every 10 generaions 
            if generation % 10 == 0:
                avg_fitness = Average(fitness_values)
                output_file.write(f"{generation}  {avg_fitness:.2f} {best_fitness} {best_strategy}\n")
                print(f"Generation {generation}, Average Fitness: {avg_fitness:.2f}, Best Fitness: {best_fitness}") 


            # selection, crossover, and mutation 
            new_population = []
            while len(new_population) < populationSize:
                par1, par2 = selectPair(population)
                child1, child2 = crossover(par1,par2,crossoverRate)
                child1 = mutate(child1, mutationRate)
                child2 = mutate(child2, mutationRate)
                new_population.extend([child1 , child2])

            population = new_population

            # demo the best strategy every 20 generations 
            if generations % 20 == 0 and best_strategy is not None:
                rw.demo(best_strategy)
                print(f"Best Strategy: {best_strategy}")
    
    # Best strategy saved
    with open('bestStrategy.txt', 'w') as bestStrategy:
        bestStrategy.write(best_strategy)

    return generations
    raiseNotDefined()


def test_FitnessFunction():
    f = fitness(rw.strategyM)
    print("Fitness for StrategyM : {0}".format(f))



# test_FitnessFunction()


runGA(100, 1.0, 0.005)